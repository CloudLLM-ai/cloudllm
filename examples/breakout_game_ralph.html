<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atari Breakout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Courier New', monospace;
            color: #00FF00;
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 3px solid #00FF00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            border-radius: 5px;
        }

        h1 {
            font-size: 32px;
            text-shadow: 0 0 10px #00FF00;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        #gameCanvas {
            border: 3px solid #00FF00;
            background: #000000;
            display: block;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            cursor: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .info-panel {
            display: flex;
            justify-content: space-around;
            width: 800px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #00FF00;
        }

        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .info-value {
            font-size: 24px;
            color: #00FF00;
        }

        .controls {
            text-align: center;
            font-size: 14px;
            color: #00FF00;
            width: 800px;
            line-height: 1.6;
        }

        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border: 3px solid #00FF00;
        }

        .menu-overlay.hidden {
            display: none;
        }

        .menu-content {
            text-align: center;
            color: #00FF00;
        }

        .menu-content h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00FF00;
        }

        .menu-content p {
            font-size: 16px;
            margin: 10px 0;
            line-height: 1.6;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .blink {
            animation: blink 0.5s infinite;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        @media (max-width: 900px) {
            .game-container {
                padding: 15px;
            }

            .info-panel, .controls {
                width: auto;
                padding: 0 15px;
            }

            h1 {
                font-size: 24px;
            }

            .info-value {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>BREAKOUT</h1>
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="menuOverlay" class="menu-overlay">
                <div class="menu-content">
                    <h2>ATARI BREAKOUT</h2>
                    <p>Destroy all bricks to advance!</p>
                    <p style="margin-top: 30px; font-size: 18px;">
                        <span class="blink">Press SPACE to Start</span>
                    </p>
                    <p style="margin-top: 40px; font-size: 14px;">
                        <strong>Controls:</strong><br>
                        Arrow Keys / A-D: Move Paddle<br>
                        Space: Fire Projectiles (when active)<br>
                        P: Pause/Resume<br>
                    </p>
                </div>
            </div>
        </div>
        <div class="info-panel">
            <div class="info-item">
                <span>SCORE</span>
                <span class="info-value" id="scoreDisplay">0</span>
            </div>
            <div class="info-item">
                <span>LIVES</span>
                <span class="info-value" id="livesDisplay">3</span>
            </div>
            <div class="info-item">
                <span>LEVEL</span>
                <span class="info-value" id="levelDisplay">1</span>
            </div>
        </div>
        <div class="controls">
            <p>Use Arrow Keys or A/D to move • Collect powerups • Destroy all bricks!</p>
        </div>
    </div>

    <script>
        "use strict";
        
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const PADDLE_WIDTH = 80;
        const PADDLE_HEIGHT = 10;
        const BALL_RADIUS = 5;
        const BRICK_WIDTH = 60;
        const BRICK_HEIGHT = 15;
        const BRICK_PADDING = 5;
        const BRICK_OFFSET_TOP = 50;
        const BRICK_OFFSET_LEFT = 40;
        const BRICK_ROWS = 5;
        const BRICK_COLS = 11;
        const MAX_BALL_SPEED = 8;
        const MIN_BALL_SPEED = 3;

        const COLORS = {
            BRICK_1HP: '#00FF00',
            BRICK_2HP: '#FFFF00',
            BRICK_3HP: '#FF0000',
            POWERUP_PADDLE: '#00FF00',
            POWERUP_SPEED: '#0000FF',
            POWERUP_PROJECTILE: '#FF0000',
            POWERUP_MULTIBALL: '#FF00FF',
            PADDLE: '#00FF00',
            BALL: '#00FF00',
            WALL: '#00FF00',
        };

        const GAME_STATES = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over',
            LEVEL_COMPLETE: 'level_complete',
        };

        let gameState = {
            state: GAME_STATES.MENU,
            score: 0,
            lives: 3,
            level: 1,
            balls: [],
            paddle: null,
            bricks: [],
            powerups: [],
            projectiles: [],
            hasProjectiles: false,
            baseSpeed: 4,
            speedMultiplier: 1.0,
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === ' ') {
                e.preventDefault();
                if (gameState.state === GAME_STATES.MENU) {
                    startGame();
                } else if (gameState.state === GAME_STATES.GAME_OVER) {
                    resetGame();
                }
                if (gameState.state === GAME_STATES.PLAYING && gameState.hasProjectiles) {
                    fireProjectiles();
                }
            }

            if (e.key === 'p' || e.key === 'P') {
                if (gameState.state === GAME_STATES.PLAYING) {
                    gameState.state = GAME_STATES.PAUSED;
                } else if (gameState.state === GAME_STATES.PAUSED) {
                    gameState.state = GAME_STATES.PLAYING;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        class Paddle {
            constructor() {
                this.baseWidth = PADDLE_WIDTH;
                this.width = PADDLE_WIDTH;
                this.height = PADDLE_HEIGHT;
                this.x = CANVAS_WIDTH / 2 - this.width / 2;
                this.y = CANVAS_HEIGHT - 30;
                this.speed = 6;
                this.maxWidth = CANVAS_WIDTH - 20;
            }

            update() {
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                    this.x -= this.speed;
                }
                if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                    this.x += this.speed;
                }

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > CANVAS_WIDTH) this.x = CANVAS_WIDTH - this.width;
            }

            draw(context) {
                context.fillStyle = COLORS.PADDLE;
                context.fillRect(this.x, this.y, this.width, this.height);
                context.strokeStyle = COLORS.PADDLE;
                context.lineWidth = 2;
                context.strokeRect(this.x, this.y, this.width, this.height);
            }

            extendPaddle() {
                const newWidth = Math.min(this.width + 10, this.maxWidth);
                const widthDiff = newWidth - this.width;
                this.width = newWidth;
                this.x = Math.max(0, Math.min(this.x - widthDiff / 2, CANVAS_WIDTH - this.width));
            }

            reset() {
                this.width = this.baseWidth;
                this.x = CANVAS_WIDTH / 2 - this.width / 2;
            }
        }

        class Ball {
            constructor(x = null, y = null, vx = null, vy = null) {
                this.x = x !== null ? x : CANVAS_WIDTH / 2;
                this.y = y !== null ? y : CANVAS_HEIGHT - 50;
                
                if (vx !== null && vy !== null) {
                    this.vx = vx;
                    this.vy = vy;
                } else {
                    const angle = (Math.random() - 0.5) * Math.PI * 0.6;
                    const speed = gameState.baseSpeed * gameState.speedMultiplier;
                    this.vx = Math.sin(angle) * speed;
                    this.vy = -Math.cos(angle) * speed;
                }
                
                this.radius = BALL_RADIUS;
                this.clampSpeed();
            }

            clampSpeed() {
                const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                
                if (speed > MAX_BALL_SPEED) {
                    const factor = MAX_BALL_SPEED / speed;
                    this.vx *= factor;
                    this.vy *= factor;
                } else if (speed < MIN_BALL_SPEED) {
                    const factor = MIN_BALL_SPEED / speed;
                    this.vx *= factor;
                    this.vy *= factor;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x - this.radius < 0 || this.x + this.radius > CANVAS_WIDTH) {
                    this.vx = -this.vx;
                    this.x = this.x - this.radius < 0 ? this.radius : CANVAS_WIDTH - this.radius;
                    playWallSound();
                }

                if (this.y - this.radius < 0) {
                    this.vy = -this.vy;
                    this.y = this.radius;
                    playWallSound();
                }

                if (this.y - this.radius > CANVAS_HEIGHT) {
                    return false;
                }

                return true;
            }

            draw(context) {
                context.fillStyle = COLORS.BALL;
                context.beginPath();
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                context.fill();
                context.strokeStyle = COLORS.BALL;
                context.lineWidth = 1;
                context.stroke();
            }

            collideWithPaddle(paddle) {
                if (this.vy <= 0) return false;

                if (
                    this.x > paddle.x &&
                    this.x < paddle.x + paddle.width &&
                    this.y + this.radius > paddle.y &&
                    this.y < paddle.y + paddle.height
                ) {
                    const hitPos = (this.x - paddle.x) / paddle.width;
                    const clampedPos = Math.max(0, Math.min(1, hitPos));
                    const angle = (clampedPos - 0.5) * Math.PI * 0.75;

                    const speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                    this.vx = Math.sin(angle) * speed;
                    this.vy = -Math.abs(Math.cos(angle) * speed);

                    this.y = paddle.y - this.radius;
                    playPaddleSound();
                    this.clampSpeed();
                    return true;
                }
                return false;
            }

            collideWithBrick(brick) {
                if (
                    this.x + this.radius > brick.x &&
                    this.x - this.radius < brick.x + brick.width &&
                    this.y + this.radius > brick.y &&
                    this.y - this.radius < brick.y + brick.height
                ) {
                    const overlapLeft = this.x + this.radius - brick.x;
                    const overlapRight = brick.x + brick.width - (this.x - this.radius);
                    const overlapTop = this.y + this.radius - brick.y;
                    const overlapBottom = brick.y + brick.height - (this.y - this.radius);

                    const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                    if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                        this.vx = -this.vx;
                        if (minOverlap === overlapLeft) {
                            this.x = brick.x - this.radius;
                        } else {
                            this.x = brick.x + brick.width + this.radius;
                        }
                    } else {
                        this.vy = -this.vy;
                        if (minOverlap === overlapTop) {
                            this.y = brick.y - this.radius;
                        } else {
                            this.y = brick.y + brick.height + this.radius;
                        }
                    }

                    playBrickSound();
                    return true;
                }
                return false;
            }
        }

        class Brick {
            constructor(x, y, hp = 1) {
                this.x = x;
                this.y = y;
                this.width = BRICK_WIDTH;
                this.height = BRICK_HEIGHT;
                this.maxHp = hp;
                this.hp = hp;
            }

            getColor() {
                if (this.hp === 1) return COLORS.BRICK_1HP;
                if (this.hp === 2) return COLORS.BRICK_2HP;
                return COLORS.BRICK_3HP;
            }

            takeDamage() {
                this.hp--;
                return this.hp <= 0;
            }

            draw(context) {
                context.fillStyle = this.getColor();
                context.fillRect(this.x, this.y, this.width, this.height);
                context.strokeStyle = '#000000';
                context.lineWidth = 1;
                context.strokeRect(this.x, this.y, this.width, this.height);

                context.fillStyle = '#000000';
                context.font = 'bold 10px Courier New';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(
                    this.hp,
                    this.x + this.width / 2,
                    this.y + this.height / 2
                );
            }
        }

        // TASK 9: POWERUP CLASS
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 20;
                this.height = 20;
                this.vy = 2;
            }

            update() {
                this.y += this.vy;
                return this.y < CANVAS_HEIGHT;
            }

            draw(context) {
                const colors = {
                    paddle: COLORS.POWERUP_PADDLE,
                    speed: COLORS.POWERUP_SPEED,
                    projectile: COLORS.POWERUP_PROJECTILE,
                    multiball: COLORS.POWERUP_MULTIBALL,
                };

                context.fillStyle = colors[this.type];
                context.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                context.strokeStyle = '#FFFFFF';
                context.lineWidth = 2;
                context.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }

            collideWithPaddle(paddle) {
                return (
                    this.x > paddle.x &&
                    this.x < paddle.x + paddle.width &&
                    this.y > paddle.y &&
                    this.y < paddle.y + paddle.height
                );
            }
        }

        // TASK 9: PROJECTILE CLASS
        class Projectile {
            constructor(x, y, vy = -6) {
                this.x = x;
                this.y = y;
                this.width = 4;
                this.height = 10;
                this.vy = vy;
            }

            update() {
                this.y += this.vy;
                return this.y > 0;
            }

            draw(context) {
                context.fillStyle = COLORS.POWERUP_PROJECTILE;
                context.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }

            collideWithBrick(brick) {
                return (
                    this.x > brick.x &&
                    this.x < brick.x + brick.width &&
                    this.y > brick.y &&
                    this.y < brick.y + brick.height
                );
            }
        }

        function createBricks() {
            gameState.bricks = [];
            for (let row = 0; row < BRICK_ROWS; row++) {
                for (let col = 0; col < BRICK_COLS; col++) {
                    const x = BRICK_OFFSET_LEFT + col * (BRICK_WIDTH + BRICK_PADDING);
                    const y = BRICK_OFFSET_TOP + row * (BRICK_HEIGHT + BRICK_PADDING);
                    const hp = Math.min(row + 1, 3);
                    gameState.bricks.push(new Brick(x, y, hp));
                }
            }
        }

        function initializeGame() {
            gameState.paddle = new Paddle();
            gameState.balls = [new Ball()];
            gameState.powerups = [];
            gameState.projectiles = [];
            gameState.hasProjectiles = false;
            gameState.baseSpeed = 4;
            gameState.speedMultiplier = 1.0;
            createBricks();
        }

        function startGame() {
            gameState.state = GAME_STATES.PLAYING;
            document.getElementById('menuOverlay').classList.add('hidden');
            initializeGame();
            startBackgroundMusic();
        }

        function resetGame() {
            gameState.state = GAME_STATES.MENU;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            document.getElementById('menuOverlay').classList.remove('hidden');
            document.querySelector('.menu-content h2').textContent = 'ATARI BREAKOUT';
            document.querySelector('.menu-content p').textContent = 'Destroy all bricks to advance!';
            updateDisplay();
            stopBackgroundMusic();
        }

        function updateDisplay() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('livesDisplay').textContent = gameState.lives;
            document.getElementById('levelDisplay').textContent = gameState.level;
        }

        // TASK 9: Fire projectiles from paddle
        function fireProjectiles() {
            if (!gameState.hasProjectiles) return;

            const projectileX1 = gameState.paddle.x + gameState.paddle.width / 3;
            const projectileX2 = gameState.paddle.x + gameState.paddle.width * 2 / 3;
            const projectileY = gameState.paddle.y - 10;

            gameState.projectiles.push(new Projectile(projectileX1, projectileY));
            gameState.projectiles.push(new Projectile(projectileX2, projectileY));
        }

        // TASK 9 & 10: Apply powerup effects
        function applyPowerup(type) {
            switch (type) {
                case 'paddle':
                    gameState.paddle.extendPaddle();
                    gameState.score += 100;
                    break;
                case 'speed':
                    gameState.speedMultiplier = Math.min(gameState.speedMultiplier + 0.1, 1.5);
                    gameState.score += 100;
                    break;
                case 'projectile':
                    gameState.hasProjectiles = true;
                    gameState.score += 150;
                    break;
                case 'multiball':
                    // TASK 10: Spawn 2 extra balls
                    for (let i = 0; i < 2; i++) {
                        const angle = (Math.random() - 0.5) * Math.PI * 0.8;
                        const speed = Math.sqrt(gameState.balls[0].vx ** 2 + gameState.balls[0].vy ** 2);
                        const newBall = new Ball(
                            gameState.paddle.x + gameState.paddle.width / 2,
                            gameState.paddle.y - 20,
                            Math.sin(angle) * speed,
                            -Math.abs(Math.cos(angle) * speed)
                        );
                        gameState.balls.push(newBall);
                    }
                    gameState.score += 300;
                    break;
            }
        }

        function checkLevelComplete() {
            if (gameState.bricks.length === 0) {
                gameState.state = GAME_STATES.LEVEL_COMPLETE;
                gameState.level++;
                gameState.lives = Math.min(gameState.lives + 1, 5);
                stopBackgroundMusic();
                setTimeout(() => {
                    initializeGame();
                    startBackgroundMusic();
                    gameState.state = GAME_STATES.PLAYING;
                }, 2000);
            }
        }

        function update() {
            if (gameState.state !== GAME_STATES.PLAYING) return;

            gameState.paddle.update();
            gameState.balls = gameState.balls.filter((ball) => ball.update());

            if (gameState.balls.length === 0) {
                gameState.lives--;
                if (gameState.lives <= 0) {
                    gameState.state = GAME_STATES.GAME_OVER;
                    document.getElementById('menuOverlay').classList.remove('hidden');
                    document.querySelector('.menu-content h2').textContent = 'GAME OVER';
                    document.querySelector('.menu-content p').textContent = `Final Score: ${gameState.score}`;
                    stopBackgroundMusic();
                } else {
                    gameState.balls.push(new Ball());
                }
            }

            gameState.balls.forEach((ball) => {
                ball.collideWithPaddle(gameState.paddle);
            });

            for (let i = gameState.bricks.length - 1; i >= 0; i--) {
                const brick = gameState.bricks[i];
                gameState.balls.forEach((ball) => {
                    if (ball.collideWithBrick(brick)) {
                        if (brick.takeDamage()) {
                            gameState.bricks.splice(i, 1);
                            gameState.score += 10 * brick.maxHp;

                            if (Math.random() < 0.15) {
                                const types = ['paddle', 'speed', 'projectile', 'multiball'];
                                const type = types[Math.floor(Math.random() * types.length)];
                                gameState.powerups.push(new Powerup(brick.x + brick.width / 2, brick.y, type));
                            }
                        }
                    }
                });
            }

            gameState.powerups = gameState.powerups.filter((powerup) => powerup.update());

            for (let i = gameState.powerups.length - 1; i >= 0; i--) {
                if (gameState.powerups[i].collideWithPaddle(gameState.paddle)) {
                    applyPowerup(gameState.powerups[i].type);
                    gameState.powerups.splice(i, 1);
                }
            }

            gameState.projectiles = gameState.projectiles.filter((projectile) => projectile.update());

            for (let i = gameState.bricks.length - 1; i >= 0; i--) {
                const brick = gameState.bricks[i];
                for (let j = gameState.projectiles.length - 1; j >= 0; j--) {
                    const projectile = gameState.projectiles[j];
                    if (projectile.collideWithBrick(brick)) {
                        if (brick.takeDamage()) {
                            gameState.bricks.splice(i, 1);
                            gameState.score += 10 * brick.maxHp;

                            if (Math.random() < 0.15) {
                                const types = ['paddle', 'speed', 'projectile', 'multiball'];
                                const type = types[Math.floor(Math.random() * types.length)];
                                gameState.powerups.push(new Powerup(brick.x + brick.width / 2, brick.y, type));
                            }
                        }
                        gameState.projectiles.splice(j, 1);
                        break;
                    }
                }
            }

            checkLevelComplete();
            updateDisplay();
        }

        function draw() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.strokeStyle = COLORS.WALL;
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState.state === GAME_STATES.PLAYING || gameState.state === GAME_STATES.PAUSED) {
                gameState.paddle.draw(ctx);
                gameState.balls.forEach((ball) => ball.draw(ctx));
                gameState.bricks.forEach((brick) => brick.draw(ctx));
                gameState.powerups.forEach((powerup) => powerup.draw(ctx));
                gameState.projectiles.forEach((projectile) => projectile.draw(ctx));

                if (gameState.state === GAME_STATES.PAUSED) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.fillStyle = COLORS.BALL;
                    ctx.font = 'bold 36px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                }
            }
        }

        // TASK 8: COLLISION SOUND EFFECTS
        let audioContext;
        let masterGain;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.connect(audioContext.destination);
                masterGain.gain.value = 0.3;
            }
        }

        // TASK 8: Ball-brick collision - high pitched blip
        function playBrickSound() {
            try {
                initAudioContext();
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(masterGain);

                osc.frequency.setValueAtTime(900, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.start(now);
                osc.stop(now + 0.1);
            } catch (e) {
                // Audio not available
            }
        }

        // TASK 8: Ball-paddle collision - medium thud
        function playPaddleSound() {
            try {
                initAudioContext();
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(masterGain);

                osc.frequency.setValueAtTime(350, now);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.start(now);
                osc.stop(now + 0.15);
            } catch (e) {
                // Audio not available
            }
        }

        // TASK 8: Ball-wall collision - low click
        function playWallSound() {
            try {
                initAudioContext();
                const now = audioContext.currentTime;
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.connect(gain);
                gain.connect(masterGain);

                osc.frequency.setValueAtTime(250, now);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                osc.start(now);
                osc.stop(now + 0.08);
            } catch (e) {
                // Audio not available
            }
        }

        let musicScheduleID = null;
        let musicIsPlaying = false;

        function startBackgroundMusic() {
            if (musicIsPlaying) return;
            try {
                initAudioContext();
                musicIsPlaying = true;

                const melody = [262, 330, 392, 494, 392, 330, 262];
                const tempo = 0.2;

                function playMelodyLoop() {
                    if (!musicIsPlaying) return;
                    if (gameState.state === GAME_STATES.PAUSED) {
                        musicScheduleID = setTimeout(playMelodyLoop, 50);
                        return;
                    }

                    const startTime = audioContext.currentTime;
                    melody.forEach((freq, index) => {
                        const noteStart = startTime + index * tempo;
                        const noteDuration = tempo * 0.9;

                        try {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();

                            osc.type = 'square';
                            osc.frequency.setValueAtTime(freq, noteStart);
                            osc.connect(gain);
                            gain.connect(masterGain);

                            gain.gain.setValueAtTime(0.08, noteStart);
                            gain.gain.exponentialRampToValueAtTime(0.01, noteStart + noteDuration);

                            osc.start(noteStart);
                            osc.stop(noteStart + noteDuration);
                        } catch (e) {
                            // Continue
                        }
                    });

                    musicScheduleID = setTimeout(playMelodyLoop, melody.length * tempo * 1000);
                }

                playMelodyLoop();
            } catch (e) {
                musicIsPlaying = false;
            }
        }

        function stopBackgroundMusic() {
            musicIsPlaying = false;
            if (musicScheduleID) {
                clearTimeout(musicScheduleID);
                musicScheduleID = null;
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameState.paddle = new Paddle();
        gameState.balls = [new Ball()];
        updateDisplay();
        gameLoop();
    </script>
</body>
</html>